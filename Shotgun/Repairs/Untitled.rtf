{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 diff --git a/src/lib/supabase.js b/src/lib/supabase.js\
index 4955c1e..df0b349 100644\
--- a/src/lib/supabase.js\
+++ b/src/lib/supabase.js\
@@ -1,140 +1,214 @@\
-import \{ createClient \} from '@supabase/supabase-js'\
-\
-// These will be environment variables in production\
-const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'your-supabase-url'\
-const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY || 'your-supabase-anon-key'\
-\
-export const supabase = createClient(supabaseUrl, supabaseAnonKey)\
-\
-// Database helper functions\
-export const timeTrackerAPI = \{\
-  // User authentication\
-  async signUp(email, password) \{\
-    const \{ data, error \} = await supabase.auth.signUp(\{\
-      email,\
-      password,\
-    \})\
-    return \{ data, error \}\
+class LocalDBManager \{\
+  constructor() \{\
+    this.currentUser = null;\
+    this._loadCurrentUser();\
+    this._initializeDefaultUsers();\
+    this._initializeDefaultJobAddressesForTestUsers();\
+  \}\
+\
+  _loadCurrentUser() \{\
+    const storedUser = localStorage.getItem('timeTracker_currentUser');\
+    if (storedUser) \{\
+      try \{\
+        this.currentUser = JSON.parse(storedUser);\
+      \} catch (e) \{\
+        console.error("Error parsing current user from localStorage", e);\
+        localStorage.removeItem('timeTracker_currentUser');\
+      \}\
+    \}\
+  \}\
+\
+  _initializeDefaultUsers() \{\
+    const users = this._getUsers();\
+    if (Object.keys(users).length === 0) \{\
+      const defaultUsers = \{\
+        'admin@test.com': \{ id: 'admin_user', email: 'admin@test.com', password: 'admin123', name: 'System Admin', role: 'admin', created_at: new Date().toISOString() \},\
+        'user1@test.com': \{ id: 'user1_id', email: 'user1@test.com', password: 'password123', name: 'John Smith', role: 'user', created_at: new Date().toISOString() \},\
+        'user2@test.com': \{ id: 'user2_id', email: 'user2@test.com', password: 'password456', name: 'Jane Doe', role: 'user', created_at: new Date().toISOString() \},\
+      \};\
+      this._saveUsers(defaultUsers);\
+      console.log('\uc0\u9989  Default test users created.');\
+    \}\
+  \}\
+  \
+  _initializeDefaultJobAddressesForTestUsers() \{\
+    const testUserIds = ['user1_id', 'user2_id'];\
+    const defaultAddresses = [\
+      '1620 Spruce St', '1710 OOB, LLC', '4 Hayden Ln', '408 Kintner LLC',\
+      '449 Saco Ave', '456 Elm Street', '50 Gorham Road Unit 2', '621 Congress St',\
+      '100 Commercial St', '25 Pearl St', '50 Monument Sq', '75 Market St',\
+      '90 Exchange St', '120 Middle St', '300 Fore St', '45 Spring St',\
+      '80 Ocean Ave', '15 Lighthouse Rd', '200 Park Ave', '30 Bay View Dr',\
+      '65 Shoreline Pkwy', '90 Harbor View', '110 Beach Rd', '22 Forest Ave',\
+      '33 River St', '44 Mountain Rd'\
+    ];\
+\
+    testUserIds.forEach(userId => \{\
+      const key = `timeTracker_job_addresses_$\{userId\}`;\
+      if (!localStorage.getItem(key)) \{\
+        const userAddresses = defaultAddresses.map((address, index) => (\{\
+          id: `$\{userId\}_addr_$\{Date.now()\}_$\{index\}`,\
+          address,\
+          user_id: userId,\
+          created_at: new Date().toISOString()\
+        \})).sort((a,b) => a.address.localeCompare(b.address));\
+        localStorage.setItem(key, JSON.stringify(userAddresses));\
+      \}\
+    \});\
+  \}\
+\
+  _getUsers() \{\
+    try \{\
+      return JSON.parse(localStorage.getItem('timeTracker_users') || '\{\}');\
+    \} catch (e) \{ return \{\}; \}\
+  \}\
+\
+  _saveUsers(users) \{\
+    localStorage.setItem('timeTracker_users', JSON.stringify(users));\
+  \}\
+\
+  async signUp(email, password, name = 'New User') \{\
+    // Simplified signUp for local mock, doesn't handle roles or advanced features\
+    const users = this._getUsers();\
+    if (users[email]) \{\
+      return \{ data: null, error: \{ message: 'User already exists.' \} \};\
+    \}\
+    const userId = `user_$\{Date.now()\}`;\
+    const newUser = \{ id: userId, email, password, name, role: 'user', created_at: new Date().toISOString() \};\
+    users[email] = newUser;\
+    this._saveUsers(users);\
+    return \{ data: \{ user: newUser \}, error: null \};\
+  \}\
+\
+  async signIn(email, password) \{\
+    const users = this._getUsers();\
+    const user = users[email];\
+    if (user && user.password === password) \{\
+      this.currentUser = user;\
+      localStorage.setItem('timeTracker_currentUser', JSON.stringify(user));\
+      return \{ data: \{ user \}, error: null \};\
+    \}\
+    return \{ data: null, error: \{ message: 'Invalid login credentials.' \} \};\
   \},\
 \
-  async signIn(email, password) \{\
-    const \{ data, error \} = await supabase.auth.signInWithPassword(\{\
-      email,\
-      password,\
-    \})\
-    return \{ data, error \}\
+  async signOut() \{\
+    this.currentUser = null;\
+    localStorage.removeItem('timeTracker_currentUser');\
+    return \{ error: null \};\
   \},\
 \
-  async signOut() \{\
-    const \{ error \} = await supabase.auth.signOut()\
-    return \{ error \}\
+  async getCurrentUser() \{\
+    return this.currentUser;\
   \},\
 \
-  async getCurrentUser() \{\
-    const \{ data: \{ user \} \} = await supabase.auth.getUser()\
-    return user\
-  \},\
-\
-  // Job addresses management\
   async getJobAddresses(userId) \{\
-    const \{ data, error \} = await supabase\
-      .from('job_addresses')\
-      .select('*')\
-      .eq('user_id', userId)\
-      .order('address')\
-    return \{ data, error \}\
+    if (!userId) return \{ data: [], error: \{ message: 'User ID is required.' \} \};\
+    const key = `timeTracker_job_addresses_$\{userId\}`;\
+    try \{\
+      const data = JSON.parse(localStorage.getItem(key) || '[]');\
+      return \{ data, error: null \};\
+    \} catch (e) \{ return \{ data: [], error: e \}; \}\
   \},\
 \
   async addJobAddress(userId, address) \{\
-    const \{ data, error \} = await supabase\
-      .from('job_addresses')\
-      .insert([\{ user_id: userId, address \}])\
-      .select()\
-    return \{ data, error \}\
+    if (!userId) return \{ data: null, error: \{ message: 'User ID is required.' \} \};\
+    const \{ data: addresses, error: getError \} = await this.getJobAddresses(userId);\
+    if (getError) return \{ data: null, error: getError \};\
+    \
+    const newAddress = \{ id: `addr_$\{Date.now()\}`, address, user_id: userId, created_at: new Date().toISOString() \};\
+    addresses.push(newAddress);\
+    addresses.sort((a, b) => a.address.localeCompare(b.address));\
+    localStorage.setItem(`timeTracker_job_addresses_$\{userId\}`, JSON.stringify(addresses));\
+    return \{ data: [newAddress], error: null \};\
   \},\
 \
   async deleteJobAddress(userId, addressId) \{\
-    const \{ error \} = await supabase\
-      .from('job_addresses')\
-      .delete()\
-      .eq('id', addressId)\
-      .eq('user_id', userId)\
-    return \{ error \}\
+    if (!userId) return \{ error: \{ message: 'User ID is required.' \} \};\
+    const \{ data: addresses, error: getError \} = await this.getJobAddresses(userId);\
+    if (getError) return \{ error: getError \};\
+\
+    const filteredAddresses = addresses.filter(addr => addr.id !== addressId);\
+    localStorage.setItem(`timeTracker_job_addresses_$\{userId\}`, JSON.stringify(filteredAddresses));\
+    return \{ error: null \};\
   \},\
 \
-  // Time entries management\
+  _getFullTimeEntries(userId) \{\
+    if (!userId) return [];\
+    const key = `timeTracker_time_entries_$\{userId\}`;\
+    try \{\
+      return JSON.parse(localStorage.getItem(key) || '[]');\
+    \} catch (e) \{ return []; \}\
+  \}\
+,\
   async getTimeEntries(userId, limit = 50) \{\
-    const \{ data, error \} = await supabase\
-      .from('time_entries')\
-      .select('*')\
-      .eq('user_id', userId)\
-      .order('created_at', \{ ascending: false \})\
-      .limit(limit)\
-    return \{ data, error \}\
+    if (!userId) return \{ data: [], error: \{ message: 'User ID is required.' \} \};\
+    let allEntries = this._getFullTimeEntries(userId);\
+    allEntries.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\
+    return \{ data: allEntries.slice(0, limit), error: null \};\
   \},\
 \
   async addTimeEntry(userId, entry) \{\
-    const \{ data, error \} = await supabase\
-      .from('time_entries')\
-      .insert([\{\
-        user_id: userId,\
-        start_time: entry.startTime,\
-        end_time: entry.endTime,\
-        duration: entry.duration,\
-        csi_division: entry.task,\
-        job_address: entry.jobAddress,\
-        notes: entry.notes,\
-        date: entry.date\
-      \}])\
-      .select()\
-    return \{ data, error \}\
+    if (!userId) return \{ data: null, error: \{ message: 'User ID is required.' \} \};\
+    let allEntries = this._getFullTimeEntries(userId);\
+    const newEntry = \{\
+      id: `entry_$\{Date.now()\}`,\
+      user_id: userId,\
+      start_time: entry.startTime,\
+      end_time: entry.endTime,\
+      duration: entry.duration,\
+      csi_division: entry.task,\
+      job_address: entry.jobAddress,\
+      notes: entry.notes,\
+      date: entry.date,\
+      created_at: new Date().toISOString()\
+    \};\
+    allEntries.unshift(newEntry); // Add to the beginning\
+    localStorage.setItem(`timeTracker_time_entries_$\{userId\}`, JSON.stringify(allEntries));\
+    return \{ data: [newEntry], error: null \};\
   \},\
 \
   async deleteTimeEntry(userId, entryId) \{\
-    const \{ error \} = await supabase\
-      .from('time_entries')\
-      .delete()\
-      .eq('id', entryId)\
-      .eq('user_id', userId)\
-    return \{ error \}\
+    if (!userId) return \{ error: \{ message: 'User ID is required.' \} \};\
+    let allEntries = this._getFullTimeEntries(userId);\
+    const filteredEntries = allEntries.filter(e => e.id !== entryId);\
+    localStorage.setItem(`timeTracker_time_entries_$\{userId\}`, JSON.stringify(filteredEntries));\
+    return \{ error: null \};\
   \},\
 \
-  // Real-time subscriptions\
-  subscribeToTimeEntries(userId, callback) \{\
-    return supabase\
-      .channel('time_entries')\
-      .on('postgres_changes', \
-        \{ \
-          event: '*', \
-          schema: 'public', \
-          table: 'time_entries',\
-          filter: `user_id=eq.$\{userId\}`\
-        \}, \
-        callback\
-      )\
-      .subscribe()\
+  async getUserStats(userId) \{\
+    if (!userId) return \{ totalEntries: 0, totalHours: 0, totalAddresses: 0, divisionBreakdown: \{\}, lastEntry: null \};\
+    const \{data: entries\} = await this.getTimeEntries(userId, Infinity); // Get all entries\
+    const \{data: addresses\} = await this.getJobAddresses(userId);\
+    \
+    const totalHours = entries.reduce((sum, entry) => sum + entry.duration, 0) / 3600;\
+    const divisionBreakdown = entries.reduce((acc, entry) => \{\
+      acc[entry.csi_division] = (acc[entry.csi_division] || 0) + entry.duration;\
+      return acc;\
+    \}, \{\});\
+\
+    return \{\
+      totalEntries: entries.length,\
+      totalHours,\
+      totalAddresses: addresses.length,\
+      divisionBreakdown,\
+      lastEntry: entries.length > 0 ? entries[0].created_at : null,\
+    \};\
   \},\
 \
-  subscribeToJobAddresses(userId, callback) \{\
-    return supabase\
-      .channel('job_addresses')\
-      .on('postgres_changes', \
-        \{ \
-          event: '*', \
-          schema: 'public', \
-          table: 'job_addresses',\
-          filter: `user_id=eq.$\{userId\}`\
-        \}, \
-        callback\
-      )\
-      .subscribe()\
-  \}\
-\} \
+  async getAllUsersData() \{\
+    const users = this._getUsers();\
+    const allData = \{\};\
+    for (const email in users) \{\
+      const user = users[email];\
+      allData[user.email] = \{\
+        user,\
+        stats: await this.getUserStats(user.id),\
+        jobAddresses: (await this.getJobAddresses(user.id)).data.length,\
+        timeEntries: (await this.getTimeEntries(user.id, Infinity)).data.length,\
+      \};\
+    \}\
+    return allData;\
+  \},\
+\
+  async clearAllData() \{\
+    Object.keys(localStorage).forEach(key => \{\
+      if (key.startsWith('timeTracker_')) \{\
+        localStorage.removeItem(key);\
+      \}\
+    \});\
+    this.currentUser = null;\
+    this._initializeDefaultUsers();\
+    this._initializeDefaultJobAddressesForTestUsers();\
+    console.log('All test data cleared and defaults re-initialized.');\
+    return \{ error: null \};\
+  \},\
+\}\
+\
+const dbManager = new LocalDBManager();\
+\
+export const timeTrackerAPI = \{\
+  signUp: (email, password, name) => dbManager.signUp(email, password, name),\
+  signIn: (email, password) => dbManager.signIn(email, password),\
+  signOut: () => dbManager.signOut(),\
+  getCurrentUser: () => dbManager.getCurrentUser(),\
+  getJobAddresses: (userId) => dbManager.getJobAddresses(userId),\
+  addJobAddress: (userId, address) => dbManager.addJobAddress(userId, address),\
+  deleteJobAddress: (userId, addressId) => dbManager.deleteJobAddress(userId, addressId),\
+  getTimeEntries: (userId, limit) => dbManager.getTimeEntries(userId, limit),\
+  addTimeEntry: (userId, entry) => dbManager.addTimeEntry(userId, entry),\
+  deleteTimeEntry: (userId, entryId) => dbManager.deleteTimeEntry(userId, entryId),\
+  getUserStats: (userId) => dbManager.getUserStats(userId),\
+  getAllUsersData: () => dbManager.getAllUsersData(),\
+  clearAllData: () => dbManager.clearAllData(),\
+\
+  // Mock Supabase-like subscription methods\
+  subscribeToTimeEntries: (userId, callback) => \{\
+    console.warn("Real-time subscriptions not available in local mock mode for time entries.");\
+    return \{ unsubscribe: () => \{\} \};\
+  \},\
+  subscribeToJobAddresses: (userId, callback) => \{\
+    console.warn("Real-time subscriptions not available in local mock mode for job addresses.");\
+    return \{ unsubscribe: () => \{\} \};\
+  \},\
+\};}